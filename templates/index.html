<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Fish Freshness Detector</title>
    <link
      href="https://cdn.jsdelivr.net/npm/tailwindcss@2.0.3/dist/tailwind.min.css"
      rel="stylesheet"
    />
    <link
      href="https://api.fontshare.com/v2/css?f[]=archivo@400&f[]=clash-display@600&display=swap"
      rel="stylesheet"
    />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Poppins:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap"
      rel="stylesheet"
    />
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
      .pred-data {
        margin-top: 2.5rem;
        margin-bottom: 1.5rem;
      }

      .legend-container {
        display: flex;
        flex-direction: row;
        gap: 10px;
      }

      .legend-item {
        display: flex;
        align-items: center;
        gap: 10px;
        font-family: "Arial", sans-serif;
        font-size: 14px;
        color: white;
      }

      .color-box {
        width: 20px;
        height: 20px;
        border-radius: 4px;
        border: 1px solid white; /* Optional border for better visibility */
      }

      #imageWrapper canvas {
        max-width: 100%; /* Ensure canvas does not overflow */
        height: auto; /* Maintain aspect ratio */
        border-radius: 1rem;
      }
      #resultDiv {
        width: 100%; /* Optional: Make resultDiv take full width of its container */
        max-width: 640px; /* Constrain width of resultDiv for consistency */
        margin: 0 auto; /* Center it horizontally */
      }

      #resultData {
        max-height: 300px;
        max-width: 100%; /* Or a fixed width like 500px */
        overflow: hidden; /* Initially hide both scrollbars */
        scrollbar-width: thin; /* Firefox: thin scrollbar */
        scrollbar-color: rgba(136, 136, 136, 0.5) #f0f0f0; /* Firefox: semi-transparent thumb and track */
      }

      /* WebKit-based browsers like Brave, Chrome, Edge */
      #resultData::-webkit-scrollbar {
        width: 6px; /* Slim vertical scrollbar */
        height: 6px; /* Slim horizontal scrollbar */
      }

      #resultData::-webkit-scrollbar-track {
        background: #f0f0f0; /* Light background for track */
        border-radius: 10rem; /* Optional: Rounded corners for track */
      }

      #resultData::-webkit-scrollbar-thumb {
        background: rgba(136, 136, 136, 0.6); /* Semi-transparent thumb */
        border-radius: 10rem; /* Rounded corners for the thumb */
      }

      #resultData::-webkit-scrollbar-thumb:hover {
        background: rgba(
          85,
          85,
          85,
          0.8
        ); /* Slightly darker and less transparent on hover */
      }

      #imageWrapper {
        display: flex;
        justify-content: center; /* Center the canvas within imageWrapper */
        align-items: center;
      }
      body {
        font-family: "Poppins", sans-serif;
        background-color: #000000;
        color: #e0e0e0;
      }

      h1 {
        font-family: "Poppins", sans-serif;
        color: #ffffff;
        font-size: 3.5rem;
        text-transform: uppercase;
        margin-top: 1rem;
        margin-bottom: 2rem;
        text-align: left;
      }

      button {
        background-color: #8b0000;
        color: #ffffff;
        font-weight: bold;
        transition: transform 0.2s, box-shadow 0.2s;
      }

      button:hover {
        box-shadow: 0 8px 16px rgba(255, 255, 255, 0.2);
      }

      .tab-button {
        background: linear-gradient(to bottom, #4c0000, #8b0000);
        color: #ffffff;
        transition: background 0.3s, box-shadow 0.3s;
        font-family: "Poppins", sans-serif; /* Apply Poppins font */
      }

      .tab-button:hover {
        box-shadow: 0 6px 12px rgba(255, 255, 255, 0.1);
      }

      .tab-button:nth-child(1) {
        /* Real-time Tab */
        background: linear-gradient(to bottom, #2e0000, #4c0000);
      }

      .tab-button:nth-child(2) {
        /* Upload Tab */
        background: linear-gradient(to bottom, #3a0000, #5c0000);
      }

      .tab-button:nth-child(3) {
        /* Capture Tab */
        background: linear-gradient(to bottom, #480000, #7c0000);
      }

      .tab-button:nth-child(4) {
        /* Batch Tab */
        background: linear-gradient(to bottom, #600000, #8b0000);
      }

      .tab-button.active {
        background: linear-gradient(to bottom, #ff3b3b, #b22222);
      }

      .info-icon {
        display: inline-block;
        width: 20px;
        height: 20px;
        background-color: #b22222;
        color: white;
        font-size: 12px;
        font-weight: bold;
        text-align: center;
        line-height: 20px;
        border-radius: 50%;
        cursor: pointer;
        position: relative;
      }

      .info-icon::after {
        content: attr(data-info);
        position: absolute;
        left: 110%; /* Adjust tooltip position */
        top: 50%;
        transform: translateY(-50%);
        background: #2a2a2a;
        color: #ffb6c1;
        padding: 8px;
        border-radius: 5px;
        font-size: 12px;
        white-space: nowrap;
        box-shadow: 0 4px 10px rgba(255, 255, 255, 0.2);
        visibility: hidden; /* Hide by default */
        opacity: 0;
        transition: opacity 0.2s, visibility 0.2s;
        z-index: 1000;
      }

      .info-icon:hover::after {
        visibility: visible; /* Show on hover */
        opacity: 1;
      }
      input,
      select {
        background-color: #2c2c2c;
        color: #ffffff;
        border: 1px solid #b22222;
      }

      pre {
        background-color: #1f1f1f;
        color: #ff7f7f;
      }

      .rounded-lg,
      .rounded-2xl,
      .rounded-3xl {
        background-color: #1a1a1a;
        box-shadow: 0 4px 8px rgba(255, 255, 255, 0.1);
      }

      .chart-container {
        position: relative;
        height: 16rem; /* Ensure enough space for charts */
      }

      .pie-chart-container {
        position: relative;
        height: 12rem; /* Adjust the height of the pie chart */
      }

      .floating-shape {
        position: absolute;
        border-radius: 50%;
        opacity: 0.2;
        filter: blur(20px);
        animation: float-animation 20s linear infinite,
          rotation-animation 20s linear infinite;
      }

      /* Keyframes for floating effect */
      @keyframes float-animation {
        0%,
        100% {
          transform: translateY(0%) translateX(0%);
        }
        50% {
          transform: translateY(100%) translateX(100%);
        }
      }

      /* Keyframes for rotation */
      @keyframes rotation-animation {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      /* Customizable shapes */
      .shape-1 {
        background-color: rgba(255, 0, 0, 0.5); /* Red shape */
        width: 100px;
        height: 100px;
        top: 10%;
        left: 20%;
        animation-delay: 0s;
      }

      .shape-2 {
        background-color: rgba(0, 255, 0, 0.5); /* Green shape */
        width: 120px;
        height: 120px;
        top: 40%;
        left: 60%;
        animation-delay: 4s;
      }

      .shape-3 {
        background-color: rgba(0, 0, 255, 0.5); /* Blue shape */
        width: 80px;
        height: 80px;
        top: 70%;
        left: 30%;
        animation-delay: 2s;
      }

      .shape-4 {
        background-color: rgba(255, 255, 0, 0.5); /* Yellow shape */
        width: 90px;
        height: 90px;
        top: 20%;
        left: 80%;
        animation-delay: 6s;
      }
    </style>
  </head>
  <body>
    <div class="floating-shape shape-1"></div>
    <div class="floating-shape shape-2"></div>
    <div class="floating-shape shape-3"></div>
    <div class="floating-shape shape-4"></div>

    <div class="min-h-screen grid grid-cols-1 md:grid-cols-3 gap-6 p-6">
      <!-- Center Column: Input Forms (Moved to the Left) -->
      <div
        class="bg-[#1E1E1E] mt-28 shadow-box rounded-3xl p-6 transition-all duration-500"
        style="transition: all 0.5s ease; box-shadow: 0 0 0 rgba(0, 0, 0, 0)"
        onmouseover="this.style.boxShadow='0 4px 30px #c1e7ec';"
        onmouseout="this.style.boxShadow='0 0 0 rgba(0, 0, 0, 0)';"
      >
        <h2
          class="text-center mt-5 text-5xl font-bold mb-2 flex items-center justify-center"
        >
          Input Forms
          <!-- Fish Outline Icon -->
          <svg
            xmlns="http://www.w3.org/2000/svg"
            class="h-10 w-10 ml-4 text-blue-500"
            fill="none"
            viewBox="0 0 24 24"
            stroke="currentColor"
            stroke-width="2"
          >
            <path
              stroke-linecap="round"
              stroke-linejoin="round"
              d="M3 12c0 2.5 2 4.5 4.5 4.5 1.28 0 2.432-.453 3.305-1.185.31.075.636.115.975.115 1.935 0 3.5-1.57 3.5-3.5s-1.565-3.5-3.5-3.5c-.34 0-.665.04-.975.115C9.932 7.953 8.78 7.5 7.5 7.5 5 7.5 3 9.5 3 12zm0 0s4.5 2 9 2 9-2 9-2m-4 5.5h1.5M17 7.5h1.5"
            />
          </svg>
        </h2>

        <p class="text-center text-md mt-5 text-white mb-10">
          Fill out the details below to analyze fish freshness and batch
          processing.
        </p>

        <form>
          <div class="mb-4">
            <label for="fishName" class="block text-sm font-medium"
              >Fish Name</label
            >
            <input
              type="text"
              id="fishName"
              placeholder="Enter fish name"
              class="mt-1 block w-full px-3 py-2 rounded-md"
            />
          </div>
          <div class="mb-4">
            <label for="fishWeight" class="block text-sm font-medium"
              >Weight (kg)</label
            >
            <input
              type="number"
              id="fishWeight"
              placeholder="Enter weight"
              class="mt-1 block w-full px-3 py-2 rounded-md"
            />
          </div>
          <button
            type="submit"
            class="w-full py-2 px-4 rounded-lg hover:shadow-lg"
            style="background: linear-gradient(to right, #8b0000, #b22222)"
          >
            Submit
          </button>
        </form>
      </div>

      <!-- Left Column: Fish Freshness Detector (Moved to the Center) -->
      <div
        class="bg-[#1E1E1E] mt-10 shadow-4xl rounded-3xl p-6 hover:bg-[#2B2B2B] transition-all duration-500"
        style="transition: all 0.5s ease; box-shadow: 0 0 0 rgba(0, 0, 0, 0)"
        onmouseover="this.style.boxShadow='0 4px 40px #c1e7ec';"
        onmouseout="this.style.boxShadow='0 0 0 rgba(0, 0, 0, 0)';"
      >
        <h1
          class="text-center text-5xl font-bold mb-10 mt-10 pulse-effect"
          style="
            color: #ffffff;
            text-shadow: 0 0 30px rgba(255, 255, 255, 1),
              0 0 40px rgba(255, 255, 255, 0.9);
          "
        >
          AquaGrade
        </h1>

        <style>
          @keyframes pulse {
            0% {
              text-shadow: 0 0 30px rgba(255, 255, 255, 1),
                0 0 40px rgba(255, 255, 255, 0.9);
            }
            50% {
              text-shadow: 0 0 50px rgba(255, 255, 255, 1),
                0 0 70px rgba(255, 255, 255, 1);
            }
            100% {
              text-shadow: 0 0 30px rgba(255, 255, 255, 1),
                0 0 40px rgba(255, 255, 255, 0.9);
            }
          }

          .pulse-effect {
            animation: pulse 1.2s infinite ease-in-out;
            font-weight: 900; /* Make the text bolder to enhance visibility */
          }
        </style>

        <!-- Option Tabs -->
        <div class="mb-4 flex justify-between shadow-lg">
          <button
            id="videoTab"
            class="tab-button active w-1/4 py-2 px-4 rounded-l-lg"
          >
            Real-time
          </button>
          <button id="uploadTab" class="tab-button w-1/4 py-2 px-4">
            Upload
          </button>
          <button id="captureTab" class="tab-button w-1/4 py-2 px-4">
            Capture
          </button>
          <button id="batchTab" class="tab-button w-1/4 py-2 px-4 rounded-r-lg">
            Batch
          </button>
        </div>

        <!-- Real-time Video Section -->
        <div id="videoSection">
          <label class="mt-8 mb-5 ml-2 block text-sm font-medium">
            Real-time video analysis
            <span
              class="info-icon"
              data-info="Analyze video frames in real-time from your webcam."
              >i</span
            >
          </label>

          <button
            id="startVideo"
            class="w-full py-2 px-4 rounded-2xl mt-2 hover:shadow-lg"
            style="background: linear-gradient(to right, #8b0000, #b22222)"
          >
            Start Real-time Analysis
          </button>

          <!-- Hidden Real-Time Video Stream -->
          <div class="flex justify-center mt-10">
            <video
              id="videoStream"
              autoplay
              class="rounded-lg shadow-lg"
              style="width: 80%; max-width: 800px; height: auto"
            ></video>
          </div>

          <div class="flex justify-center mt-10">
            <label class="block text-lg font-semibold text-center mb-2">
              Inference Result:
            </label>
          </div>

          <!-- Inference Result -->
          <div class="flex justify-center">
            <pre
              id="videoResultData"
              class="p-4 rounded-lg overflow-auto text-sm shadow-lg"
              style="
                width: 80%;
                max-width: 800px;
                background-color: #1f1f1f;
                color: #ff7f7f;
                /* videoResultData */
              "
            ></pre>
          </div>
        </div>

        <!-- Upload Image Section -->
        <form id="uploadForm" enctype="multipart/form-data" class="hidden">
          <div class="mb-4">
            <label for="file" class="block mt-8 mb-5 ml-2 text-sm font-medium">
              Upload an image
              <span
                class="info-icon"
                data-info="Upload a single image from your device for freshness detection."
                >i</span
              >
            </label>
            <input
              type="file"
              id="file"
              name="file"
              accept="image/*"
              class="mt-1 block w-full px-3 py-2 rounded-md shadow-lg"
            />
          </div>
          <button
            type="submit"
            class="w-full py-2 px-4 rounded-2xl hover:shadow-lg mb-10"
            style="background: linear-gradient(to right, #8b0000, #b22222)"
          >
            Upload Image
          </button>
        </form>

        <!-- Capture Image Section -->
        <div id="captureSection" class="hidden">
          <label class="block text-sm font-medium text-white mt-5 mb-5">
            Capture an image
            <span
              class="info-icon"
              data-info="Use this feature to capture an image directly from your webcam. Ensure camera permissions are granted."
              >i</span
            >
          </label>
          <button
            id="startWebcam"
            class="w-full py-2 px-4 bg-black text-white rounded-lg hover:bg-gray-900 shadow-lg mt-2"
            style="
              font-family: 'Clash Display', sans-serif;
              background: linear-gradient(to right, #8b0000, #b22222);
            "
          >
            Start Webcam
          </button>
          <video
            id="webcam"
            autoplay
            class="mt-4 w-full rounded-lg shadow-lg hidden"
          ></video>
          <canvas id="snapshot" class="hidden"></canvas>
          <button
            id="capture"
            class="w-full py-2 px-4 bg-black text-white rounded-lg mt-2 hover:bg-gray-900 shadow-lg hidden"
          >
            Capture Image
          </button>
        </div>

        <!-- Batch Upload Section -->
        <form id="batchForm" enctype="multipart/form-data" class="hidden">
          <div class="mb-4">
            <label for="files" class="block text-sm mt-8 mb-5 ml-2 font-medium">
              Upload multiple images
              <span
                class="info-icon"
                data-info="Upload multiple images for batch processing."
                >i</span
              >
            </label>
            <input
              type="file"
              id="files"
              name="files"
              accept="image/*"
              multiple
              class="mt-1 block w-full px-3 py-2 rounded-md shadow-lg"
            />
          </div>
          <button
            type="submit"
            class="w-full py-2 px-4 rounded-2xl hover:shadow-lg"
            style="background: linear-gradient(to right, #8b0000, #b22222)"
          >
            Upload Batch
          </button>
        </form>

        <!-- Result Display -->
        <div id="resultDiv" class="mt-4 hidden">
          <h2 class="text-lg font-semibold">Inference Result:</h2>
          <div id="imageWrapper" class="mt-4 flex justify-center"></div>
          <h2 class="pred-data text-lg font-semibold">Prediction Data:</h2>
          <pre
            id="resultData"
            class="p-4 rounded-lg text-sm shadow-lg"
            style="max-height: 125px; overflow-y: auto; overflow-x: auto"
          ></pre>
        </div>

        <!-- Quality Legend -->
        <div id="qualityLegend" class="legend-container mt-10 font-semibold">
          <h2>Quality Legend:</h2>
        </div>
      </div>

      <!-- Right Column: Charts -->
      <div class="min-h-screen grid grid-cols-1 md:grid-cols-3 gap-6 p-6">
        <!-- Existing Content -->

        <!-- Right Column: Charts -->
        <div
          class="mt-20 bg-gradient-to-br from-[#333333] to-[#444444] shadow-box rounded-3xl p-6 md:col-span-3 relative-position transition-all duration-500"
          style="transition: all 0.5s ease; box-shadow: 0 0 0 rgba(0, 0, 0, 0)"
          onmouseover="this.style.boxShadow='0 4px 30px #c1e7ec';"
          onmouseout="this.style.boxShadow='0 0 0 rgba(0, 0, 0, 0)';"
        >
          <h2 class="text-center mt-10 text-5xl font-bold mb-4">Charts</h2>

          <!-- Animated Counter Div (Positioned at Top-Left) -->
          <div
            class="stats shadow-lg w-24 h-14 content-center absolute top-40 rounded-3xl bg-[#333333] text-white font-bold font-poppins transition-transform duration-500 ease-in-out hover:scale-105 scale-75"
            style="right: 79px; box-shadow: 0 3px 15px rgba(255, 0, 0, 0.8)"
            onmouseover="this.style.boxShadow='0 4px 18px rgba(255, 0, 0, 1)';"
            onmouseout="this.style.boxShadow='0 3px 15px rgba(255, 0, 0, 0.8)';"
          >
            <div class="stat text-left flex items-center justify-between px-4">
              <div class="stat-value text-sm mr-2 text-white" id="count">0</div>
              <!-- Eye Icon -->
              <svg
                xmlns="http://www.w3.org/2000/svg"
                class="h-10 w-10 text-white"
                fill="none"
                viewBox="0 0 24 24"
                stroke="currentColor"
                stroke-width="1.5"
              >
                <path
                  stroke-linecap="round"
                  stroke-linejoin="round"
                  d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"
                />
                <path
                  stroke-linecap="round"
                  stroke-linejoin="round"
                  d="M2.458 12C3.732 7.943 7.523 5 12 5c4.477 0 8.268 2.943 9.542 7-1.274 4.057-5.065 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"
                />
              </svg>
            </div>
          </div>

          <!-- Moving Pie Chart -->
          <div class="mt-20 pie-chart-container">
            <canvas id="pieChart"></canvas>
          </div>

          <!-- Reactive Line Chart -->
          <div class="chart-container mt-4">
            <canvas id="lineChart"></canvas>
          </div>
        </div>
      </div>

      <script>
        // Counter Animation Script
        document.addEventListener("DOMContentLoaded", function () {
          const targetNumber = 89400;
          const speed = 50;

          const counter = document.getElementById("count");
          let count = 0;

          const updateCount = () => {
            const increment = Math.ceil(targetNumber / speed);
            count += increment;

            if (count < targetNumber) {
              counter.textContent = count.toLocaleString();
              setTimeout(updateCount, 30);
            } else {
              counter.textContent = targetNumber.toLocaleString();
            }
          };

          updateCount();
        });

        // Chart.js Configuration (Remaining Existing Chart Logic)
        const ctxPie = document.getElementById("pieChart").getContext("2d");
        const pieChart = new Chart(ctxPie, {
          type: "doughnut",
          data: {
            labels: ["Fresh", "Not Fresh"],
            datasets: [
              {
                label: "Freshness Distribution",
                data: [70, 30],
                backgroundColor: [
                  "#4CAF50",
                  ctxPie.createLinearGradient(0, 0, 0, 400),
                ],
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: { labels: { color: "#FFFFFF" } },
            },
          },
        });

        const ctxLine = document.getElementById("lineChart").getContext("2d");
        const gradientLine = ctxLine.createLinearGradient(0, 0, 400, 0);
        gradientLine.addColorStop(0, "#FF0000");
        gradientLine.addColorStop(1, "#FFFFFF");

        const lineChart = new Chart(ctxLine, {
          type: "line",
          data: {
            labels: ["1s", "2s", "3s", "4s", "5s", "6s", "7s"],
            datasets: [
              {
                label: "Freshness Over Time",
                data: [10, 12, 14, 18, 22, 20, 25],
                borderColor: gradientLine,
                backgroundColor: "rgba(255, 0, 0, 0.2)",
                tension: 0.4,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              x: { ticks: { color: "#E0E0E0" } },
              y: { ticks: { color: "#E0E0E0" } },
            },
            plugins: {
              legend: { labels: { color: "#FFFFFF" } },
            },
          },
        });

        // Simulate updates every 3 seconds
        setInterval(() => {
          const newLabel = `${lineChart.data.labels.length + 1}s`;
          const newData = Math.floor(Math.random() * 50);

          lineChart.data.labels.push(newLabel);
          lineChart.data.datasets[0].data.push(newData);
          lineChart.update();

          const freshValue = Math.floor(Math.random() * 100);
          const notFreshValue = 100 - freshValue;
          pieChart.data.datasets[0].data = [freshValue, notFreshValue];
          pieChart.update();
        }, 3000);
      </script>
    </div>

    <script>
      // Original JavaScript logic provided
      const uploadForm = document.getElementById("uploadForm");
      const batchForm = document.getElementById("batchForm");
      const resultDiv = document.getElementById("resultDiv");
      const resultData = document.getElementById("resultData");
      const videoResultData = document.getElementById("videoResultData");
      const captureSection = document.getElementById("captureSection");
      const videoSection = document.getElementById("videoSection");
      const webcam = document.getElementById("webcam");
      const videoStream = document.getElementById("videoStream");
      const snapshot = document.getElementById("snapshot");
      const capture = document.getElementById("capture");
      const startWebcam = document.getElementById("startWebcam");
      const startVideo = document.getElementById("startVideo");
      const uploadTab = document.getElementById("uploadTab");
      const captureTab = document.getElementById("captureTab");
      const batchTab = document.getElementById("batchTab");
      const videoTab = document.getElementById("videoTab");

      let streaming = false;

      document.addEventListener("DOMContentLoaded", () => {
        // Initialize default state on page load
        setDefaultState();
      });

      //   START OF HELPER FUNCTIONS ZONE
      function setDefaultState() {
        const legendContainer = document.getElementById("qualityLegend");

        if (!legendContainer) {
          console.error("Element with ID 'qualityLegend' not found.");
          return;
        }

        legendContainer.innerHTML = `
            <div class="legend-item">
                <span>No predictions available. Please upload or capture an image.</span>
            </div>
        `;
      }
      function generateShade(baseColor, factor) {
        const hexToRgb = (hex) => {
          let bigint = parseInt(hex.slice(1), 16);
          let r = (bigint >> 16) & 255;
          let g = (bigint >> 8) & 255;
          let b = bigint & 255;
          return [r, g, b];
        };

        const rgbToHex = (r, g, b) => {
          return (
            "#" +
            ((1 << 24) + (r << 16) + (g << 8) + b)
              .toString(16)
              .slice(1)
              .toUpperCase()
          );
        };

        const [r, g, b] = hexToRgb(baseColor).map((c) =>
          Math.min(255, Math.floor(c * factor))
        );

        return rgbToHex(r, g, b);
      }

      // Function to filter and format the label dynamically
      function filterLabel(rawLabel, confidence) {
        const confidencePercentage = (confidence * 100).toFixed(1); // Format confidence as percentage

        let processedLabel = rawLabel.replaceAll(" ", "");

        // Split the raw label into parts by " - "
        const labelParts = processedLabel.split("-");

        // Extract the first and last parts, ignoring the middle (numeric) part
        let classLabel = labelParts[0]; // e.g., "TILAPIA", "SKIN", "EYE"
        let qualityLabel = "";

        if (labelParts.length > 2) {
          // If 3 parts, extract class and quality, ignore the middle numeric part
          qualityLabel = labelParts[2].replace("-", ""); // e.g., "Acceptable"
        } else if (labelParts.length === 2) {
          // If 2 parts, extract class and quality
          qualityLabel = labelParts[1].replace("-", ""); // e.g., "Excellent"
        }

        // Return formatted string with confidence
        return `${classLabel} (${confidencePercentage}%)`;
      }

      function getContrastColor(r, g, b) {
        // Calculate brightness based on perceived luminance formula
        const brightness = (r * 299 + g * 587 + b * 114) / 1000;
        return brightness > 128 ? "black" : "white";
      }

      const baseColor = "#FF0000"; // Base color (red)
      const classShades = {}; // Store shades for each class

      function generateQualityLegend(predictions) {
        const legendContainer = document.getElementById("qualityLegend");

        if (!legendContainer) {
          console.error("Element with ID 'qualityLegend' not found.");
          return;
        }

        // Clear previous content
        legendContainer.innerHTML = "";

        if (!predictions || predictions.length === 0) {
          setDefaultState(); // Set default message when no predictions
          return;
        }

        const labelCounts = {};

        predictions.forEach((prediction) => {
          const label = prediction.class;
          labelCounts[label] = (labelCounts[label] || 0) + 1;

          if (!classShades[label]) {
            const index = Object.keys(classShades).length;
            const shadeFactor = 0.6 + index * 0.1;
            classShades[label] = generateShade(baseColor, shadeFactor);
          }
        });

        Object.keys(labelCounts).forEach((label) => {
          const count = labelCounts[label];
          const shade = classShades[label];

          const legendItem = document.createElement("div");
          legendItem.classList.add("legend-item");

          const colorBox = document.createElement("div");
          colorBox.style.backgroundColor = shade;
          colorBox.classList.add("color-box");

          const labelText = document.createElement("span");
          labelText.innerText = `${label} (${count})`;

          legendItem.appendChild(colorBox);
          legendItem.appendChild(labelText);

          legendContainer.appendChild(legendItem);
        });
      }

      function displayImageWithBoundingBoxes(
        imageUrl,
        predictions,
        targetWidth = 640,
        targetHeight = 640
      ) {
        const canvas = document.createElement("canvas");
        const ctx = canvas.getContext("2d");
        const img = new Image();

        img.onload = () => {
          canvas.width = img.width;
          canvas.height = img.height;
          ctx.drawImage(img, 0, 0);

          predictions.forEach((prediction, index) => {
            const {
              x,
              y,
              width,
              height,
              class: label,
              confidence,
            } = prediction;

            // Assign a shade to class if not already assigned
            if (!classShades[label]) {
              const shadeFactor = 0.6 + index * 0.1; // Adjust brightness per class
              classShades[label] = generateShade(baseColor, shadeFactor);
            }

            const shade = classShades[label]; // Get shade for this class
            const [r, g, b] = shade
              .slice(1)
              .match(/.{2}/g)
              .map((hex) => parseInt(hex, 16));
            const textColor = getContrastColor(r, g, b);

            // Draw bounding box
            ctx.strokeStyle = shade;
            ctx.lineWidth = 3;
            ctx.strokeRect(x - width / 2, y - height / 2, width, height);

            const text = filterLabel(label, confidence);

            ctx.font = "bold 14px Arial";
            const textWidth = ctx.measureText(text).width;
            const textHeight = 12; // Approximate text height
            const isVerticalBox = height > width;

            if (isVerticalBox) {
              // Place the label horizontally on the left side of the box, aligned to the bottom-left corner
              ctx.fillStyle = shade; // Background color
              ctx.fillRect(
                x - width / 2 - 2, // Move label left, next to the bounding box
                y - height / 2 - 16, // Align to bottom-left corner
                textWidth + 6,
                textHeight + 4
              );

              ctx.fillStyle = textColor; // Text color
              ctx.fillText(
                text,
                x - width / 2 - 2, // Align the text inside the background rectangle
                y - height / 2 - 2.5 // Adjust to center text vertically
              );
            } else {
              // For horizontal label placement (unchanged)
              ctx.fillStyle = shade;
              ctx.fillRect(
                x - width / 2,
                y - height / 2 - textHeight - 4,
                textWidth + 2,
                textHeight + 4
              );

              ctx.fillStyle = textColor;
              ctx.fillText(text, x - width / 2, y - height / 1.85);
            }
          });

          // Resize canvas proportionally
          const resizedCanvas = document.createElement("canvas");
          const resizedCtx = resizedCanvas.getContext("2d");
          resizedCanvas.width = targetWidth;
          resizedCanvas.height = targetHeight;

          resizedCtx.drawImage(canvas, 0, 0, targetWidth, targetHeight);

          // Ensure canvas fits within the container
          const imageWrapper = document.getElementById("imageWrapper");
          imageWrapper.innerHTML = ""; // Clear previous image
          imageWrapper.appendChild(resizedCanvas); // Append resized canvas
        };

        img.src = imageUrl;
      }

      // Start Webcam
      startWebcam.addEventListener("click", async () => {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({
            video: true,
          });
          webcam.srcObject = stream;
          webcam.classList.remove("hidden");
          capture.classList.remove("hidden");

          //   displayImageWithBoundingBoxes(imageUrl, predictionData);
        } catch (error) {
          console.error("Webcam access error:", error);
          alert(
            "Failed to access the camera. Please allow permissions and try again."
          );
        }
      });

      async function analyzeFrame() {
        if (!streaming) return;

        const videoCanvas = document.createElement("canvas");
        videoCanvas.width = 640;
        videoCanvas.height =
          (640 / videoStream.videoWidth) * videoStream.videoHeight;
        const videoContext = videoCanvas.getContext("2d");
        videoContext.drawImage(
          videoStream,
          0,
          0,
          videoCanvas.width,
          videoCanvas.height
        );

        videoCanvas.toBlob(async (blob) => {
          const formData = new FormData();
          formData.append("file", blob, "frame.jpg");

          try {
            const response = await fetch("/upload-single-image", {
              method: "POST",
              body: formData,
            });

            if (!response.ok) {
              throw new Error("Network response was not ok");
            }

            // stringifying the json data.
            const data = await response.json();
            videoResultData.textContent = JSON.stringify(data, null, 2);
          } catch (error) {
            console.error("Error:", error);
          }
        }, "image/jpeg");

        setTimeout(analyzeFrame, 500); // Process a frame every 500ms, to not bombard the Inference API Endpoint
      }
      // END OF HELPER FUNCTIONS ZONE

      // Show both scrollbars when user hovers
      resultData.addEventListener("mouseenter", () => {
        resultData.style.overflowY = "scroll"; // Enable vertical scrollbar
        resultData.style.overflowX = "scroll"; // Enable horizontal scrollbar
      });

      // Hide both scrollbars when the mouse leaves
      resultData.addEventListener("mouseleave", () => {
        resultData.style.overflowY = "hidden"; // Hide vertical scrollbar
        resultData.style.overflowX = "hidden"; // Hide horizontal scrollbar
      });

      // Ensure scrollbars remain visible while actively scrolling
      resultData.addEventListener("scroll", () => {
        resultData.style.overflowY = "scroll";
        resultData.style.overflowX = "scroll";
      });

      // Tab Switching
      const allTabs = [uploadTab, captureTab, batchTab, videoTab];
      const sections = [uploadForm, captureSection, batchForm, videoSection];

      allTabs.forEach((tab, index) => {
        tab.addEventListener("click", () => {
          sections.forEach((section, i) => {
            if (index === i) {
              section.classList.remove("hidden");
              allTabs[i].classList.add("active");
            } else {
              section.classList.add("hidden");
              allTabs[i].classList.remove("active");
            }
          });
          resultDiv.classList.add("hidden"); // Hide result when switching tabs
        });
      });

      // Capture Image
      capture.addEventListener("click", () => {
        const context = snapshot.getContext("2d");
        snapshot.width = webcam.videoWidth;
        snapshot.height = webcam.videoHeight;
        context.drawImage(webcam, 0, 0, snapshot.width, snapshot.height);

        snapshot.toBlob(async (blob) => {
          const formData = new FormData();
          formData.append("file", blob, "snapshot.jpg");

          try {
            const response = await fetch("/upload-single-image", {
              method: "POST",
              body: formData,
            });

            if (!response.ok) {
              throw new Error("Upload failed.");
            }

            const data = await response.json();
            resultData.textContent = JSON.stringify(data, null, 2);
            resultDiv.classList.remove("hidden");

            let predictionData = data.predictions;
            const file = formData.get("file");
            const imageUrl = URL.createObjectURL(file);

            displayImageWithBoundingBoxes(imageUrl, predictionData);
            generateQualityLegend(predictionData); // Update legend dynamically
          } catch (error) {
            console.error("Error uploading snapshot:", error);
            alert("Snapshot upload failed.");
          }
        }, "image/jpeg");
      });

      uploadForm.addEventListener("submit", async (e) => {
        e.preventDefault();
        const formData = new FormData(uploadForm);
        let imageWrapper = document.getElementById("imageWrapper");

        try {
          const response = await fetch("/upload-single-image", {
            method: "POST",
            body: formData,
          });

          if (!response.ok) {
            throw new Error("Failed to upload image.");
          }

          const data = await response.json();
          resultData.textContent = JSON.stringify(data, null, 2);
          resultDiv.classList.remove("hidden");

          let predictionData = data.predictions;
          const file = formData.get("file");
          const imageUrl = URL.createObjectURL(file);

          displayImageWithBoundingBoxes(imageUrl, predictionData);
          generateQualityLegend(predictionData); // Update legend dynamically
        } catch (error) {
          console.error("Error:", error);
        }
      });

      // Batch Form Submission
      batchForm.addEventListener("submit", async (e) => {
        e.preventDefault();
        const formData = new FormData(batchForm);

        try {
          const response = await fetch("/upload-batch-images", {
            method: "POST",
            body: formData,
          });

          if (!response.ok) {
            throw new Error("Failed to upload batch.");
          }

          const data = await response.json();
          resultData.textContent = JSON.stringify(data, null, 2);
          resultDiv.classList.remove("hidden");
        } catch (error) {
          console.error("Error:", error);
        }
      });

      // Start Real-Time Video Analysis
      startVideo.addEventListener("click", async () => {
        if (!streaming) {
          const stream = await navigator.mediaDevices.getUserMedia({
            video: true,
          });
          videoStream.srcObject = stream;
          streaming = true;
          analyzeFrame();
        }
      });
    </script>
  </body>
</html>
