<!DOCTYPE html>
<html lang="en">
    <head>
    <meta charset="UTF-8" / />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" / />
    <title>Fish Freshness Detector</title>
    <link
      href="https://cdn.jsdelivr.net/npm/tailwindcss@2.0.3/dist/tailwind.min.css"
      rel="stylesheet"
    />
    <link
      href="https://api.fontshare.com/v2/css?f[]=archivo@400&f[]=clash-display@600&display=swap"
      rel="stylesheet"
    />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Poppins:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap"
      rel="stylesheet"
    />
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
      .semi-transparent-container {
        background-color: rgba(
          255,
          255,
          255,
          0.05
        ); /* Semi-transparent white background */
        padding: 20px;
        border-radius: 10px; /* Rounded corners */
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); /* Subtle shadow for a raised effect */
        text-align: center; /* Center the text */
        width: 100%; /* Ensure full container use */
        max-width: 400px; /* Constrain width for better appearance */
        align-items: center;
        justify-items: center;
      }

      .not-available-image {
        max-width: 5rem; /* Resize the image for a reasonable size */
        height: auto;
        /* margin-bottom: 5px; Space between image and text */
      }

      .not-available-text {
        font-size: 0.5rem; /* Reasonably sized text */
        color: #f0f0f0; /* Darker text for better contrast */
      }
      .not-available {
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        border-radius: 14px; /* Optional rounded corners */
        padding: 20px;
        background-color: rgba(136, 136, 136, 0.05);
      }
      .pred-data {
        margin-top: 2.5rem;
        margin-bottom: 1.5rem;
      }

      .legend-container {
        position: relative;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        min-height: 200px; /* Adjust as necessary */
        border-radius: 14px; /* Optional rounded corners */
        background-color: rgba(136, 136, 136, 0.05);
      }

      .legend-item {
        display: flex;
        align-items: center;
        gap: 10px;
        font-family: "Arial", sans-serif;
        font-size: 14px;
        color: white;
      }

      .color-box {
        width: 20px;
        height: 20px;
        border-radius: 4px;
        border: 1px solid white; /* Optional border for better visibility */
      }

      #imageWrapper canvas {
        max-width: 100%; /* Ensure canvas does not overflow */
        height: auto; /* Maintain aspect ratio */
        border-radius: 1rem;
      }
      #resultDiv {
        width: 100%; /* Optional: Make resultDiv take full width of its container */
        max-width: 640px; /* Constrain width of resultDiv for consistency */
        margin: 0 auto; /* Center it horizontally */
      }

      #resultData {
        max-height: 300px;
        max-width: 100%; /* Or a fixed width like 500px */
        overflow: hidden; /* Initially hide both scrollbars */
        scrollbar-width: thin; /* Firefox: thin scrollbar */
        scrollbar-color: rgba(136, 136, 136, 0.5) #f0f0f0; /* Firefox: semi-transparent thumb and track */
      }

      /* WebKit-based browsers like Brave, Chrome, Edge */
      #resultData::-webkit-scrollbar {
        width: 6px; /* Slim vertical scrollbar */
        height: 6px; /* Slim horizontal scrollbar */
      }

      #resultData::-webkit-scrollbar-track {
        background: #f0f0f0; /* Light background for track */
        border-radius: 10rem; /* Optional: Rounded corners for track */
      }

      #resultData::-webkit-scrollbar-thumb {
        background: rgba(136, 136, 136, 0.6); /* Semi-transparent thumb */
        border-radius: 10rem; /* Rounded corners for the thumb */
      }

      #resultData::-webkit-scrollbar-thumb:hover {
        background: rgba(
          85,
          85,
          85,
          0.8
        ); /* Slightly darker and less transparent on hover */
      }

      #imageWrapper {
        display: flex;
        justify-content: center; /* Center the canvas within imageWrapper */
        align-items: center;
      }
      body {
        font-family: "Poppins", sans-serif;
        background-color: #000000;
        color: #e0e0e0;
      }

      h1 {
        font-family: "Poppins", sans-serif;
        color: #ffffff;
        font-size: 3.5rem;
        text-transform: uppercase;
        margin-top: 1rem;
        margin-bottom: 2rem;
        text-align: left;
      }

      button {
        background-color: #8b0000;
        color: #ffffff;
        font-weight: bold;
        transition: transform 0.2s, box-shadow 0.2s;
      }

      button:hover {
        box-shadow: 0 8px 16px rgba(255, 255, 255, 0.2);
      }

      .tab-button {
        background: linear-gradient(to bottom, #4c0000, #8b0000);
        color: #ffffff;
        transition: background 0.3s, box-shadow 0.3s;
        font-family: "Poppins", sans-serif; /* Apply Poppins font */
      }

      .tab-button:hover {
        box-shadow: 0 6px 12px rgba(255, 255, 255, 0.1);
      }

      .tab-button:nth-child(1) {
        /* Real-time Tab */
        background: linear-gradient(to bottom, #2e0000, #4c0000);
      }

      .tab-button:nth-child(2) {
        /* Upload Tab */
        background: linear-gradient(to bottom, #3a0000, #5c0000);
      }

      .tab-button:nth-child(3) {
        /* Capture Tab */
        background: linear-gradient(to bottom, #480000, #7c0000);
      }

      .tab-button:nth-child(4) {
        /* Batch Tab */
        background: linear-gradient(to bottom, #600000, #8b0000);
      }

      .tab-button.active {
        background: linear-gradient(to bottom, #ff3b3b, #b22222);
      }

      .info-icon {
        display: inline-block;
        width: 20px;
        height: 20px;
        background-color: #b22222;
        color: white;
        font-size: 12px;
        font-weight: bold;
        text-align: center;
        line-height: 20px;
        border-radius: 50%;
        cursor: pointer;
        position: relative;
      }

      .info-icon::after {
        content: attr(data-info);
        position: absolute;
        left: 110%; /* Adjust tooltip position */
        top: 50%;
        transform: translateY(-50%);
        background: #2a2a2a;
        color: #ffb6c1;
        padding: 8px;
        border-radius: 5px;
        font-size: 12px;
        white-space: nowrap;
        box-shadow: 0 4px 10px rgba(255, 255, 255, 0.2);
        visibility: hidden; /* Hide by default */
        opacity: 0;
        transition: opacity 0.2s, visibility 0.2s;
        z-index: 1000;
      }

      .info-icon:hover::after {
        visibility: visible; /* Show on hover */
        opacity: 1;
      }
      input,
      select {
        background-color: #2c2c2c;
        color: #ffffff;
        border: 1px solid #b22222;
      }

      pre {
        background-color: #1f1f1f;
        color: #ff7f7f;
      }

      .rounded-lg,
      .rounded-2xl,
      .rounded-3xl {
        background-color: #1a1a1a;
        box-shadow: 0 4px 8px rgba(255, 255, 255, 0.1);
      }

      .chart-container {
        position: relative;
        height: 16rem; /* Ensure enough space for charts */
      }

      .pie-chart-container {
        position: relative;
        height: 12rem; /* Adjust the height of the pie chart */
        }
        .popup {
        position: absolute;
        top: 20%;
        left: 10%;
        background-color: #1a1a1a;
        width: 20%; /* Adjusted width */
        padding: 20px;
        border-radius: 10px;
        box-shadow: 0 4px 8px rgba(255, 255, 255, 0.2);
        z-index: 1000;
        display: none;
      }

      .popup h2 {
        font-size: 1.5rem;
        margin-bottom: 1rem;
        color: #ff6b6b;
      }

      .popup-options {
        display: flex;
        flex-direction: column;
        gap: 10px;
      }

      .popup-options label {
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .popup-options input[type="radio"] {
        margin: 0;
      }

      .popup button {
        background-color: #ff3b3b;
        width: 100%;
        padding: 10px;
        border-radius: 6px;
        text-align: center;
      }

      .popup button:hover {
        background-color: #ff6b6b;
      }

      .check-icon::after {
        content: "âœ“";
        color: green;
        margin-left: 10px;
      }

      .answer-text {
        color: red; /* Make the text and checkmark red */
        font-weight: bold;
      }

          
    .progress-bar-animated {
        background-image: linear-gradient(
            45deg,
            rgba(255, 255, 255, 0.15) 25%,
            transparent 25%,
            transparent 50%,
            rgba(255, 255, 255, 0.15) 50%,
            rgba(255, 255, 255, 0.15) 75%,
            transparent 75%,
            transparent
        );
        background-size: 2rem 2rem;
        animation: progressAnimation 1s linear infinite;
        background-color: #B22222;
    }
    </style>
  </head>
  <body>
    <div class="min-h-screen grid grid-cols-1 md:grid-cols-3 gap-6 p-6">
      <!-- Center Column: Input Forms -->
      <div class="bg-[#1E1E1E] shadow-box rounded-3xl p-6">
        <h2 class="text-center text-4xl font-bold mb-4">Fish Assessment Form</h2>
        <p>
          This form allows you to assess the fish based on various attributes such as appearance, gill color, and eye clarity. Ensure all
          sections are completed for a thorough evaluation.
        </p>
        <br />
        border-radius: 50%;
        opacity: 0.2;
        filter: blur(20px);
        animation: float-animation 20s linear infinite,
          rotation-animation 20s linear infinite;
      }

      /* Keyframes for floating effect */
      @keyframes float-animation {
        0%,
        100% {
          transform: translateY(0%) translateX(0%);
        }
        50% {
          transform: translateY(100%) translateX(100%);
        }
      }

      /* Keyframes for rotation */
      @keyframes rotation-animation {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      /* Customizable shapes */
      .shape-1 {
        background-color: rgba(255, 0, 0, 0.5); /* Red shape */
        width: 100px;
        height: 100px;
        top: 10%;
        left: 20%;
        animation-delay: 0s;
      }

      .shape-2 {
        background-color: rgba(0, 255, 0, 0.5); /* Green shape */
        width: 120px;
        height: 120px;
        top: 40%;
        left: 60%;
        animation-delay: 4s;
      }

      .shape-3 {
        background-color: rgba(0, 0, 255, 0.5); /* Blue shape */
        width: 80px;
        height: 80px;
        top: 70%;
        left: 30%;
        animation-delay: 2s;
      }

      .shape-4 {
        background-color: rgba(255, 255, 0, 0.5); /* Yellow shape */
        width: 90px;
        height: 90px;
        top: 20%;
        left: 80%;
        animation-delay: 6s;
      }
    </style>
  </head>
  <body>
    <div class="floating-shape shape-1"></div>
    <div class="floating-shape shape-2"></div>
    <div class="floating-shape shape-3"></div>
    <div class="floating-shape shape-4"></div>

    <div class="min-h-screen grid grid-cols-1 md:grid-cols-3 gap-6 p-6">
      <!-- Center Column: Input Forms (Moved to the Left) -->
      <div
        class="bg-[#1E1E1E] mt-28 shadow-box rounded-3xl p-6 transition-all duration-500"
        style="transition: all 0.5s ease; box-shadow: 0 0 0 rgba(0, 0, 0, 0)"
        onmouseover="this.style.boxShadow='0 4px 30px #c1e7ec';"
        onmouseout="this.style.boxShadow='0 0 0 rgba(0, 0, 0, 0)';"
      >
        <h2
          class="text-center mt-5 text-5xl font-bold mb-2 flex items-center justify-center"
        >
          Input Forms
          <!-- Fish Outline Icon -->
          <svg
            xmlns="http://www.w3.org/2000/svg"
            class="h-10 w-10 ml-4 text-blue-500"
            fill="none"
            viewBox="0 0 24 24"
            stroke="currentColor"
            stroke-width="2"
          >
            <path
              stroke-linecap="round"
              stroke-linejoin="round"
              d="M3 12c0 2.5 2 4.5 4.5 4.5 1.28 0 2.432-.453 3.305-1.185.31.075.636.115.975.115 1.935 0 3.5-1.57 3.5-3.5s-1.565-3.5-3.5-3.5c-.34 0-.665.04-.975.115C9.932 7.953 8.78 7.5 7.5 7.5 5 7.5 3 9.5 3 12zm0 0s4.5 2 9 2 9-2 9-2m-4 5.5h1.5M17 7.5h1.5"
            />
          </svg>
        </h2>

        <p class="text-center text-md mt-5 text-white mb-10">
          Fill out the details below to analyze fish freshness and batch
          processing.
        </p>

        <form>
          <div class="mb-4">
            <label for="generalAppearance" class="block text-sm font-medium">General Appearance</label>
            <select
              id="generalAppearance"
              class="dropdown mt-1 block w-full px-3 py-2 rounded-md bg-[#2c2c2c] text-white border border-[#b22222]"
            >
              <option value="" disabled selected>Skin, Bloodspots, Stiffness and Smell (Please Select)</option>
              <option value="brightness">Rate the brightness of the skin</option>
              <option value="bloodspot">Scale of bloodspots found on the gills</option>
              <option value="stiffness">Rate the stiffness of the fish</option>
              <option value="belly">Firmness of the belly</option>
              <option value="smellofthefish">Identify the smell of the fish</option>
            </select>
          </div>
          <div class="mb-4">
            <label for="eyes" class="block text-sm font-medium">Eyes</label>
            <select id="eyes" class="dropdown mt-1 block w-full px-3 py-2 rounded-md bg-[#2c2c2c] text-white border border-[#b22222]">
              <option value="" disabled selected>Clarity & Shape (Please Select)</option>
              <option value="clarity">Clear Eyes</option>
              <option value="shape">Sunken or Bulging</option>
            </select>
          </div>
          <div class="mb-4">
            <label for="gills" class="block text-sm font-medium">Gills</label>
            <select id="gills" class="dropdown mt-1 block w-full px-3 py-2 rounded-md bg-[#2c2c2c] text-white border border-[#b22222]">
              <option value="" disabled selected>Colour & Smell (Please Select)</option>
              <option value="colour">Check color of gills</option>
              <option value="smell">Identify smell of gills</option>
            </select>
          </div>
          <button
            type="submit"
            class="w-full py-2 px-4 rounded-lg hover:shadow-lg"
            style="background: linear-gradient(to right, #8b0000, #b22222)"
          >
            Submit
          </button>

          <!-- Result Display Section -->
          <div id="resultDisplay" class="mt-4 hidden">
            <h3 class="text-lg font-semibold">Result (Quality): <span id="qualityResult"></span></h3>
          </div>

          <!-- Download Links Section -->
          <div id="downloadLinks" class="mt-4 hidden">
            <h3 class="text-lg font-semibold mb-2">Download your files:</h3>
            <a id="downloadPDF" href="#" class="block text-blue-500 hover:underline">Download PDF</a>
            <a id="downloadExcel" href="#" class="block text-blue-500 hover:underline">Download Excel</a>
          </div>
          <div class="mb-4">
            <label for="fishName" class="block text-sm font-medium"
              >Fish Name</label
            >
            <input
              type="text"
              id="fishName"
              placeholder="Enter fish name"
              class="mt-1 block w-full px-3 py-2 rounded-md"
            />
          </div>
          <div class="mb-4">
            <label for="fishWeight" class="block text-sm font-medium"
              >Weight (kg)</label
            >
            <input
              type="number"
              id="fishWeight"
              placeholder="Enter weight"
              class="mt-1 block w-full px-3 py-2 rounded-md"
            />
          </div>
          <button
            type="submit"
            class="w-full py-2 px-4 rounded-lg hover:shadow-lg"
            style="background: linear-gradient(to right, #8b0000, #b22222)"
          >
            Submit
          </button>
        </form>
      </div>
      </div>

      <!-- Popup -->
      <div class="popup" id="popup">
        <h2 class="text-xl font-bold mb-4" id="popupTitle">Select an Option</h2>
        <form id="popupForm">
          <div id="popupOptions" class="popup-options"></div>
          <button type="button" id="closePopup" class="mt-4 px-4 py-2 rounded bg-red-600 text-white">Submit</button>
        </form>
      </div>

      <div class="bg-[#1E1E1E] mt-10 shadow-4xl rounded-3xl p-6 hover:bg-[#2B2B2B] transition-all duration-500" style="transition: all 0.5s ease; box-shadow: 0 0 0 rgba(0, 0, 0, 0);" onmouseover="this.style.boxShadow='0 4px 40px #c1e7ec';" onmouseout="this.style.boxShadow='0 0 0 rgba(0, 0, 0, 0)';">
        <h1 class="text-center text-5xl font-bold mb-10 mt-10 pulse-effect" style="color: #FFFFFF; text-shadow: 0 0 30px rgba(255, 255, 255, 1), 0 0 40px rgba(255, 255, 255, 0.9);">AquaGrade</h1>
        <style>
            @keyframes pulse {
                0% {
                    text-shadow: 0 0 30px rgba(255, 255, 255, 1), 0 0 40px rgba(255, 255, 255, 0.9);
                }
                50% {
                    text-shadow: 0 0 50px rgba(255, 255, 255, 1), 0 0 70px rgba(255, 255, 255, 1);
                }
                100% {
                    text-shadow: 0 0 30px rgba(255, 255, 255, 1), 0 0 40px rgba(255, 255, 255, 0.9);
                }
            }
            .pulse-effect {
                animation: pulse 1.2s infinite ease-in-out;
                font-weight: 900;
            }
        </style>
        <div class="mb-4 flex justify-between shadow-lg">
          <button
            id="videoTab"
            class="tab-button active w-1/4 py-2 px-4 rounded-l-lg"
          >
            Real-time
          </button>
          <button id="uploadTab" class="tab-button w-1/4 py-2 px-4">
            Upload
          </button>
          <button id="captureTab" class="tab-button w-1/4 py-2 px-4">
            Capture
          </button>
          <button id="batchTab" class="tab-button w-1/4 py-2 px-4 rounded-r-lg">
            Batch
          </button>
        </div>
        <div id="videoSection">
          <label class="mt-8 mb-5 ml-2 block text-sm font-medium">
            Real-time video analysis
            <span
              class="info-icon"
              data-info="Analyze video frames in real-time from your webcam."
              >i</span
            >
          </label>

          <button
            id="startVideo"
            class="w-full py-2 px-4 rounded-2xl mt-2 hover:shadow-lg"
            style="background: linear-gradient(to right, #8b0000, #b22222)"
          >
            Start Real-time Analysis
          </button>

          <!-- Hidden Real-Time Video Stream -->
          <div class="flex justify-center mt-10">
            <video
              id="videoStream"
              autoplay
              class="rounded-lg shadow-lg"
              style="width: 80%; max-width: 800px; height: auto"
            ></video>
          </div>

          <div class="flex justify-center mt-10">
            <label class="block text-lg font-semibold text-center mb-2">
              Inference Result:
            </label>
          </div>

          <!-- Inference Result -->
          <div class="flex justify-center">
            <pre
              id="videoResultData"
              class="p-4 rounded-lg overflow-auto text-sm shadow-lg"
              style="
                width: 80%;
                max-width: 800px;
                background-color: #1f1f1f;
                color: #ff7f7f;
                /* videoResultData */
              "
            ></pre>
          </div>
            <label class="mt-8 mb-5 ml-2 block text-sm font-medium">Real-time video analysis<span class="info-icon" data-info="Analyze video frames in real-time from your webcam.">i</span></label>
            <button id="startVideo" class="w-full py-2 px-4 rounded-2xl mt-2 hover:shadow-lg" style="background: linear-gradient(to right, #8B0000, #B22222);">Start Real-time Analysis</button>
            <div class="flex justify-center mt-10">
                <video id="videoStream" autoplay class="rounded-lg shadow-lg" style="width: 80%; max-width: 800px; height: auto;"></video>
            </div>
            <div class="flex justify-center mt-10">
                <label class="block text-lg font-semibold text-center mb-2">Inference Result:</label>
            </div>
            <div class="flex justify-center">
                <pre id="videoResultData" class="p-4 rounded-lg overflow-auto text-sm shadow-lg" style="width: 80%; max-width: 800px; background-color: #1F1F1F; color: #FF7F7F;"></pre>
            </div>
        </div>
        <form id="uploadForm" enctype="multipart/form-data" class="hidden">
          <div class="mb-4">
            <label for="file" class="block mt-8 mb-5 ml-2 text-sm font-medium">
              Upload an image
              <span
                class="info-icon"
                data-info="Upload a single image from your device for freshness detection."
                >i</span
              >
            </label>
            <input
              type="file"
              id="file"
              name="file"
              accept="image/*"
              class="mt-1 block w-full px-3 py-2 rounded-md shadow-lg"
            />
          </div>
          <button
            type="submit"
            class="w-full py-2 px-4 rounded-2xl hover:shadow-lg mb-10"
            style="background: linear-gradient(to right, #8b0000, #b22222)"
          >
            Upload Image
          </button>
        </form>

        <!-- Capture Image Section -->
            <div class="mb-4">
                <label for="file" class="block mt-8 mb-5 ml-2 text-sm font-medium">Upload an image<span class="info-icon" data-info="Upload a single image from your device for freshness detection.">i</span></label>
                <input type="file" id="file" name="file" accept="image/*" class="mt-1 block w-full px-3 py-2 rounded-md shadow-lg">
            </div>
            <div id="uploadProgress" class="mt-8 mb-8 hidden w-full max-w-4xl mx-auto">
                <div class="relative">
                    <div class="w-full bg-gray-800 rounded-full h-4 dark:bg-gray-700 overflow-hidden">
                        <div id="uploadProgressValue" 
                             class="h-4 rounded-full transition-all duration-700 ease-in-out progress-bar-animated" 
                             style="width: 0%; background-color: #B22222;">
                        </div>
                    </div>
                    <span id="uploadProgressPercentage" 
                          class="absolute left-1/2 top-1/2 transform -translate-x-1/2 -translate-y-1/2 text-sm font-bold text-white min-w-[50px] text-center">0%</span>
                </div>
            </div>
            <button type="submit" class="w-full py-2 px-4 rounded-2xl hover:shadow-lg" style="background: linear-gradient(to right, #8B0000, #B22222);">Upload Image</button>
            
            <div id="uploadResultDiv" class="mt-4 hidden">
                <h2 class="text-lg font-semibold">Inference Result:</h2>
                <pre id="uploadResultData" class="p-4 rounded-lg overflow-auto text-sm shadow-lg" style="background-color: #1F1F1F; color: #FF7F7F;"></pre>
            </div>
        </form>
        <div id="captureSection" class="hidden">
          <label class="block text-sm font-medium text-white mt-5 mb-5">
            Capture an image
            <span
              class="info-icon"
              data-info="Use this feature to capture an image directly from your webcam. Ensure camera permissions are granted."
              >i</span
            >
          </label>
          <button
            id="startWebcam"
            class="w-full py-2 px-4 bg-black text-white rounded-lg hover:bg-gray-900 shadow-lg mt-2"
            style="
              font-family: 'Clash Display', sans-serif;
              background: linear-gradient(to right, #8b0000, #b22222);
            "
          >
            Start Webcam
          </button>
          <video
            id="webcam"
            autoplay
            class="mt-4 w-full rounded-lg shadow-lg hidden"
          ></video>
          <canvas id="snapshot" class="hidden"></canvas>
          <button
            id="capture"
            class="w-full py-2 px-4 bg-black text-white rounded-lg mt-2 hover:bg-gray-900 shadow-lg hidden"
          >
            Capture Image
          </button>
            <label class="block text-sm font-medium text-white mt-5 mb-5">Capture an image<span class="info-icon" data-info="Use this feature to capture an image directly from your webcam. Ensure camera permissions are granted.">i</span></label>
            <button id="startWebcam" class="w-full py-2 px-4 bg-black text-white rounded-lg hover:bg-gray-900 shadow-lg mt-2" style="font-family: 'Clash Display', sans-serif;background: linear-gradient(to right, #8B0000, #B22222);">Start Webcam</button>
            <video id="webcam" autoplay class="mt-4 w-full rounded-lg shadow-lg hidden"></video>
            <canvas id="snapshot" class="hidden"></canvas>
            <button id="capture" class="w-full py-2 px-4 bg-black text-white rounded-lg mt-2 hover:bg-gray-900 shadow-lg hidden">Capture Image</button>
        </div>
        <form id="batchForm" enctype="multipart/form-data" class="hidden">
            <div class="mb-4">
                <label for="files" class="block text-sm mt-8 mb-5 ml-2 font-medium">Upload multiple images<span class="info-icon" data-info="Upload multiple images for batch processing.">i</span></label>
                <input type="file" id="files" name="files" accept="image/*" multiple class="mt-1 block w-full px-3 py-2 rounded-md shadow-lg">
            </div>
            <div id="batchProgress" class="mt-8 mb-8 hidden w-full max-w-4xl mx-auto">
                <div class="relative">
                    <div class="w-full bg-gray-800 rounded-full h-4 dark:bg-gray-700 overflow-hidden">
                        <div id="batchProgressValue" 
                             class="h-4 rounded-full transition-all duration-700 ease-in-out progress-bar-animated" 
                             style="width: 0%">
                        </div>
                    </div>
                    <span id="batchProgressPercentage" 
                          class="absolute left-1/2 top-1/2 transform -translate-x-1/2 -translate-y-1/2 text-sm font-bold text-white min-w-[50px] text-center">0%</span>
                </div>
            </div>
            <button type="submit" class="w-full py-2 px-4 rounded-2xl hover:shadow-lg" style="background: linear-gradient(to right, #8B0000, #B22222);">Upload Batch</button>
            
            <div id="batchResultDiv" class="mt-4 hidden">
                <h2 class="text-lg font-semibold">Batch Processing Results:</h2>
                <pre id="batchResultData" class="p-4 rounded-lg overflow-auto text-sm shadow-lg" style="background-color: #1F1F1F; color: #FF7F7F;"></pre>
            </div>
        </form>
          <div class="mb-4">
            <label for="files" class="block text-sm mt-8 mb-5 ml-2 font-medium">
              Upload multiple images
              <span
                class="info-icon"
                data-info="Upload multiple images for batch processing."
                >i</span
              >
            </label>
            <input
              type="file"
              id="files"
              name="files"
              accept="image/*"
              multiple
              class="mt-1 block w-full px-3 py-2 rounded-md shadow-lg"
            />
          </div>
          <button
            type="submit"
            class="w-full py-2 px-4 rounded-2xl hover:shadow-lg"
            style="background: linear-gradient(to right, #8b0000, #b22222)"
          >
            Upload Batch
          </button>
        </form>

        <!-- Result Display -->
        <div id="resultDiv" class="mt-4 hidden">
          <h2 class="text-lg font-semibold">Inference Result:</h2>
          <div id="imageWrapper" class="mt-4 flex justify-center"></div>
          <h2 class="pred-data text-lg font-semibold">Prediction Data:</h2>
          <pre
            id="resultData"
            class="p-4 rounded-lg text-sm shadow-lg"
            style="max-height: 125px; overflow-y: auto; overflow-x: auto"
          ></pre>
        </div>

        <!-- Quality Legend -->
        <h2 class="mt-12 mb-5 font-semibold">Quality Legend:</h2>
        <div id="qualityLegend" class="legend-container font-semibold"></div>
      </div>

      <!-- Right Column: Charts -->
      <div class="min-h-screen grid grid-cols-1 md:grid-cols-3 gap-6 p-6">
        <!-- Existing Content -->

        <!-- Right Column: Charts -->
        <div
          class="mt-20 bg-gradient-to-br from-[#333333] to-[#444444] shadow-box rounded-3xl p-6 md:col-span-3 relative-position transition-all duration-500"
          style="transition: all 0.5s ease; box-shadow: 0 0 0 rgba(0, 0, 0, 0)"
          onmouseover="this.style.boxShadow='0 4px 30px #c1e7ec';"
          onmouseout="this.style.boxShadow='0 0 0 rgba(0, 0, 0, 0)';"
        >
          <h2 class="text-center mt-10 text-5xl font-bold mb-4">Charts</h2>

          <!-- Animated Counter Div (Positioned at Top-Left) -->
          <div
            class="stats shadow-lg w-24 h-14 content-center absolute top-40 rounded-3xl bg-[#333333] text-white font-bold font-poppins transition-transform duration-500 ease-in-out hover:scale-105 scale-75"
            style="right: 79px; box-shadow: 0 3px 15px rgba(255, 0, 0, 0.8)"
            onmouseover="this.style.boxShadow='0 4px 18px rgba(255, 0, 0, 1)';"
            onmouseout="this.style.boxShadow='0 3px 15px rgba(255, 0, 0, 0.8)';"
          >
            <div class="stat text-left flex items-center justify-between px-4">
              <div class="stat-value text-sm mr-2 text-white" id="count">0</div>
              <!-- Eye Icon -->
              <svg
                xmlns="http://www.w3.org/2000/svg"
                class="h-10 w-10 text-white"
                fill="none"
                viewBox="0 0 24 24"
                stroke="currentColor"
                stroke-width="1.5"
              >
                <path
                  stroke-linecap="round"
                  stroke-linejoin="round"
                  d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"
                />
                <path
                  stroke-linecap="round"
                  stroke-linejoin="round"
                  d="M2.458 12C3.732 7.943 7.523 5 12 5c4.477 0 8.268 2.943 9.542 7-1.274 4.057-5.065 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"
                />
              </svg>
            </div>
          </div>

          <!-- Moving Pie Chart -->
          <div class="mt-20 pie-chart-container">
            <canvas id="pieChart"></canvas>
          </div>

          <!-- Reactive Line Chart -->
          <div class="chart-container mt-4">
            <canvas id="lineChart"></canvas>
          </div>
    </div>
    <div class="min-h-screen grid grid-cols-1 md:grid-cols-3 gap-6 p-6">
        <div class="mt-20 bg-gradient-to-br from-[#333333] to-[#444444] shadow-box rounded-3xl p-6 md:col-span-3 relative-position transition-all duration-500" style="transition: all 0.5s ease; box-shadow: 0 0 0 rgba(0, 0, 0, 0);" onmouseover="this.style.boxShadow='0 4px 30px #c1e7ec';" onmouseout="this.style.boxShadow='0 0 0 rgba(0, 0, 0, 0)';">
            <h2 class="text-center mt-10 text-5xl font-bold mb-4">Charts</h2>
            <div class="stats shadow-lg w-24 h-14 content-center absolute top-40 rounded-3xl bg-[#333333] text-white font-bold font-poppins transition-transform duration-500 ease-in-out hover:scale-105 scale-75" style="right: 79px; box-shadow: 0 3px 15px rgba(255, 0, 0, 0.8);" onmouseover="this.style.boxShadow='0 4px 18px rgba(255, 0, 0, 1)';" onmouseout="this.style.boxShadow='0 3px 15px rgba(255, 0, 0, 0.8)';">
                <div class="stat text-left flex items-center justify-between px-4">
                    <div class="stat-value text-sm mr-2 text-white" id="count">0</div>
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-10 w-10 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="1.5">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                        <path stroke-linecap="round" stroke-linejoin="round" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.477 0 8.268 2.943 9.542 7-1.274 4.057-5.065 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" />
                    </svg>
                </div>
            </div>
            <div class="mt-20 pie-chart-container">
                <canvas id="pieChart"></canvas>
            </div>
            <div class="chart-container mt-4">
                <canvas id="lineChart"></canvas>
            </div>
        </div>
      </div>
      <script>
        document.addEventListener("DOMContentLoaded", function () {
          const targetNumber = 89400;
          const speed = 50;
          const counter = document.getElementById("count");
          let count = 0;
          const updateCount = () => {
            const increment = Math.ceil(targetNumber / speed);
            count += increment;
            if (count < targetNumber) {
              counter.textContent = count.toLocaleString();
              setTimeout(updateCount, 30);
            } else {
              counter.textContent = targetNumber.toLocaleString();
            }
          };
          updateCount();
        });
        const ctxPie = document.getElementById("pieChart").getContext("2d");
        const pieChart = new Chart(ctxPie, {
          type: "doughnut",
          data: {
            labels: ["Fresh", "Not Fresh"],
            datasets: [
              {
                label: "Freshness Distribution",
                data: [70, 30],
                backgroundColor: [
                  "#4CAF50",
                  ctxPie.createLinearGradient(0, 0, 0, 400),
                ],
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: { labels: { color: "#FFFFFF" } },
            },
          },
        });
        const ctxLine = document.getElementById("lineChart").getContext("2d");
        const gradientLine = ctxLine.createLinearGradient(0, 0, 400, 0);
        gradientLine.addColorStop(0, "#FF0000");
        gradientLine.addColorStop(1, "#FFFFFF");
        const lineChart = new Chart(ctxLine, {
          type: "line",
          data: {
            labels: ["1s", "2s", "3s", "4s", "5s", "6s", "7s"],
            datasets: [
              {
                label: "Freshness Over Time",
                data: [10, 12, 14, 18, 22, 20, 25],
                borderColor: gradientLine,
                backgroundColor: "rgba(255, 0, 0, 0.2)",
                tension: 0.4,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              x: { ticks: { color: "#E0E0E0" } },
              y: { ticks: { color: "#E0E0E0" } },
            },
            plugins: {
              legend: { labels: { color: "#FFFFFF" } },
            },
          },
        });
        setInterval(() => {
          const newLabel = `${lineChart.data.labels.length + 1}s`;
          const newData = Math.floor(Math.random() * 50);
          lineChart.data.labels.push(newLabel);
          lineChart.data.datasets[0].data.push(newData);
          lineChart.update();
          const freshValue = Math.floor(Math.random() * 100);
          const notFreshValue = 100 - freshValue;
          pieChart.data.datasets[0].data = [freshValue, notFreshValue];
          pieChart.update();
        }, 3000);
      </script>
    </div>

    <script>
      // Original JavaScript logic provided
      const uploadForm = document.getElementById("uploadForm");
      const batchForm = document.getElementById("batchForm");
      const resultDiv = document.getElementById("resultDiv");
      const resultData = document.getElementById("resultData");
      const videoResultData = document.getElementById("videoResultData");
      const captureSection = document.getElementById("captureSection");
      const videoSection = document.getElementById("videoSection");
      const webcam = document.getElementById("webcam");
      const videoStream = document.getElementById("videoStream");
      const snapshot = document.getElementById("snapshot");
      const capture = document.getElementById("capture");
      const startWebcam = document.getElementById("startWebcam");
      const startVideo = document.getElementById("startVideo");
      const uploadTab = document.getElementById("uploadTab");
      const captureTab = document.getElementById("captureTab");
      const batchTab = document.getElementById("batchTab");
      const videoTab = document.getElementById("videoTab");

      let streaming = false;

      document.addEventListener("DOMContentLoaded", () => {
        // Initialize default state on page load
        setDefaultState();
      });

      // Helper function to set the default state with a placeholder
      function setDefaultState() {
        const legendContainer = document.getElementById("qualityLegend");

        if (!legendContainer) {
          console.error("Element with ID 'qualityLegend' not found.");
          return;
        }

        legendContainer.innerHTML = `
    <div class="not-available">
        <div class="semi-transparent-container">
            <img src="{{ url_for('static', filename='assets/empty-box.png') }}" class="not-available-image" alt="No data">
            <span class="not-available-text">Empty or no predictions available. Please upload or capture an image.</span>
        </div>
    </div>
  `;
      }

      // Function to clean the label
      function cleanLabel(label) {
        // Step 1: Replace all hyphens with spaces for general readability
        let processedLabel = label.replaceAll("-", " ");

        // Step 2: Remove numbers that are connected to the "to" keyword (e.g., "6 to 10")
        processedLabel = processedLabel.replace(/\d+\s+to\s+\d+/g, "");

        // Step 3: Move numbers that were between hyphens into square brackets
        // This finds numbers that were originally between hyphens and puts them in [ ]
        processedLabel = processedLabel.replace(/\b(\d+)\b/g, "[$1]");

        // Step 4: Remove any extra whitespace that may have been introduced
        return processedLabel.trim();
      }

      // Function to get contrasting text color (black or white) based on background color
      function getContrastColor(r, g, b) {
        const brightness = 0.2126 * r + 0.7152 * g + 0.0722 * b;
        return brightness < 128 ? "#FFFFFF" : "#000000";
      }

      // Define a distinct color for each class
      const classColors = {
        "BANGUS -0 to 5 - Spoiled-": "#FF5733",
        "BANGUS -11 to 12 - Extremely Fresh-": "#33FF57",
        "BANGUS -6 to 10 - Fresh-": "#3357FF",
        "EYE -0 - Unacceptable-": "#FF33A1",
        "EYE -1 - Poor Quality-": "#FF8C00",
        "EYE -2 - Marginal-": "#8C33FF",
        "EYE -3 - Acceptable-": "#FFD700",
        "EYE -4 - Good Quality-": "#FF6347",
        "EYE -5 - High Quality-": "#4682B4",
        "EYE -6 - Prime Quality-": "#00FF7F",
        "SKIN -0 - Unacceptable-": "#800000",
        "SKIN -1 - Poor Quality-": "#B8860B",
        "SKIN -2 - Marginal-": "#008080",
        "SKIN -3 - Acceptable-": "#FF4500",
        "SKIN -4 - Good Quality-": "#9400D3",
        "SKIN -5 - High Quality-": "#5F9EA0",
        "SKIN -6 - Prime Quality-": "#D2691E",
        "TILAPIA -0 to 5 - Spoiled-": "#808000",
        "TILAPIA -11 to 12 - Extremely Fresh-": "#CD5C5C",
        "TILAPIA -6 to 10 - Fresh-": "#2E8B57",
      };

      const classShades = {}; // Store assigned colors for each class

      function generateQualityLegend(predictions) {
        const legendContainer = document.getElementById("qualityLegend");

        if (!legendContainer) {
          console.error("Element with ID 'qualityLegend' not found.");
          return;
        }

        // Clear previous content
        legendContainer.innerHTML = "";

        if (!predictions || predictions.length === 0) {
          setDefaultState();
          return;
        }

        const labelCounts = {};

        predictions.forEach((prediction) => {
          const label = prediction.class;

          // Increment count for each unique label
          labelCounts[label] = (labelCounts[label] || 0) + 1;

          // Assign color from classColors or a fallback color if undefined
          if (!classShades[label]) {
            classShades[label] = classColors[label] || "#808080"; // Default to grey if not found
          }
        });

        // Create the quality legend
        Object.keys(labelCounts).forEach((quality) => {
          const count = labelCounts[quality];
          const shade = classShades[quality];

          const legendItem = document.createElement("div");
          legendItem.classList.add("legend-item");

          const colorBox = document.createElement("div");
          colorBox.style.backgroundColor = shade;
          colorBox.classList.add("color-box");

          const labelText = document.createElement("span");

          // Clean the label and assign the cleaned label text
          const cleanedLabel = cleanLabel(quality);
          labelText.innerText = `${cleanedLabel} (${count})`;

          console.log(cleanedLabel);

          legendItem.appendChild(colorBox);
          legendItem.appendChild(labelText);

          legendContainer.appendChild(legendItem);
        });

        if (Object.keys(labelCounts).length === 0) {
          setDefaultState();
        }
      }

      function displayImageWithBoundingBoxes(
        imageUrl,
        predictions,
        targetWidth = 640,
        targetHeight = 640
      ) {
        const canvas = document.createElement("canvas");
        const ctx = canvas.getContext("2d");
        const img = new Image();

        img.onload = () => {
          canvas.width = img.width;
          canvas.height = img.height;
          ctx.drawImage(img, 0, 0);

          predictions.forEach((prediction) => {
            const {
              x,
              y,
              width,
              height,
              class: label,
              confidence,
            } = prediction;

            // Assign color from predefined colors or fallback color
            if (!classShades[label]) {
              classShades[label] = classColors[label] || "#808080"; // Default to grey if not found
            }

            const shade = classShades[label];
            const [r, g, b] = shade
              .slice(1)
              .match(/.{2}/g)
              .map((hex) => parseInt(hex, 16));
            const textColor = getContrastColor(r, g, b);

            // Draw bounding box
            ctx.strokeStyle = shade;
            ctx.lineWidth = 3;
            ctx.strokeRect(x - width / 2, y - height / 2, width, height);

            const text = filterLabel(label, confidence);

            ctx.font = "bold 14px Arial";
            const textWidth = ctx.measureText(text).width;
            const textHeight = 12;

            // Draw label background and text
            ctx.fillStyle = shade;
            ctx.fillRect(
              x - width / 2,
              y - height / 2 - textHeight - 4,
              textWidth + 2,
              textHeight + 4
            );

            ctx.fillStyle = textColor;
            ctx.fillText(text, x - width / 2, y - height / 1.85);
          });

          // Resize canvas proportionally
          const resizedCanvas = document.createElement("canvas");
          const resizedCtx = resizedCanvas.getContext("2d");
          resizedCanvas.width = targetWidth;
          resizedCanvas.height = targetHeight;

          resizedCtx.drawImage(canvas, 0, 0, targetWidth, targetHeight);

          // Append the resized canvas to the image wrapper
          const imageWrapper = document.getElementById("imageWrapper");
          imageWrapper.innerHTML = ""; // Clear previous image
          imageWrapper.appendChild(resizedCanvas);
        };

        img.src = imageUrl;
      }

      // Function to filter and format the label dynamically
      function filterLabel(rawLabel, confidence) {
        const confidencePercentage = (confidence * 100).toFixed(1); // Format confidence as percentage
        let processedLabel = rawLabel.replaceAll(" ", "");
        const labelParts = processedLabel.split("-");

        let classLabel = labelParts[0]; // e.g., "TILAPIA", "SKIN", "EYE"
        let qualityLabel = "";

        if (labelParts.length > 2) {
          qualityLabel = labelParts[2].replace("-", ""); // e.g., "Acceptable"
        } else if (labelParts.length === 2) {
          qualityLabel = labelParts[1].replace("-", ""); // e.g., "Excellent"
        }

        // Return formatted string with confidence
        return `${classLabel} (${confidencePercentage}%)`;
      }

      // Start Webcam
      startWebcam.addEventListener("click", async () => {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({
            video: true,
          });
          webcam.srcObject = stream;
          webcam.classList.remove("hidden");
          capture.classList.remove("hidden");

          //   displayImageWithBoundingBoxes(imageUrl, predictionData);
        } catch (error) {
          console.error("Webcam access error:", error);
          alert(
            "Failed to access the camera. Please allow permissions and try again."
          );
        }
      });

      async function analyzeFrame() {
        if (!streaming) return;

        const videoCanvas = document.createElement("canvas");
        videoCanvas.width = 640;
        videoCanvas.height =
          (640 / videoStream.videoWidth) * videoStream.videoHeight;
        const videoContext = videoCanvas.getContext("2d");
        videoContext.drawImage(
          videoStream,
          0,
          0,
          videoCanvas.width,
          videoCanvas.height
        );

        videoCanvas.toBlob(async (blob) => {
          const formData = new FormData();
          formData.append("file", blob, "frame.jpg");

          try {
            const response = await fetch("/upload-single-image", {
              method: "POST",
              body: formData,
            });

            if (!response.ok) {
              throw new Error("Network response was not ok");
            }

            // stringifying the json data.
            const data = await response.json();
            videoResultData.textContent = JSON.stringify(data, null, 2);
          } catch (error) {
            console.error("Error:", error);
          }
        }, "image/jpeg");

        setTimeout(analyzeFrame, 500); // Process a frame every 500ms, to not bombard the Inference API Endpoint
      }
      // END OF HELPER FUNCTIONS ZONE

      // Show both scrollbars when user hovers
      resultData.addEventListener("mouseenter", () => {
        resultData.style.overflowY = "scroll"; // Enable vertical scrollbar
        resultData.style.overflowX = "scroll"; // Enable horizontal scrollbar
      });

      // Hide both scrollbars when the mouse leaves
      resultData.addEventListener("mouseleave", () => {
        resultData.style.overflowY = "hidden"; // Hide vertical scrollbar
        resultData.style.overflowX = "hidden"; // Hide horizontal scrollbar
      });

      // Ensure scrollbars remain visible while actively scrolling
      resultData.addEventListener("scroll", () => {
        resultData.style.overflowY = "scroll";
        resultData.style.overflowX = "scroll";
      });

      // Tab Switching
      const allTabs = [uploadTab, captureTab, batchTab, videoTab];
      const sections = [uploadForm, captureSection, batchForm, videoSection];

      allTabs.forEach((tab, index) => {
        tab.addEventListener("click", () => {
          sections.forEach((section, i) => {
            if (index === i) {
              section.classList.remove("hidden");
              allTabs[i].classList.add("active");
            } else {
              section.classList.add("hidden");
              allTabs[i].classList.remove("active");
            }
          });
          resultDiv.classList.add("hidden"); // Hide result when switching tabs
          setDefaultState();
        });
      });

      // Capture Image
      capture.addEventListener("click", () => {
        const context = snapshot.getContext("2d");
        snapshot.width = webcam.videoWidth;
        snapshot.height = webcam.videoHeight;
        context.drawImage(webcam, 0, 0, snapshot.width, snapshot.height);

        snapshot.toBlob(async (blob) => {
          const formData = new FormData();
          formData.append("file", blob, "snapshot.jpg");

          try {
            const response = await fetch("/upload-single-image", {
              method: "POST",
              body: formData,
            });

            if (!response.ok) {
              throw new Error("Upload failed.");
            }

            const data = await response.json();
            resultData.textContent = JSON.stringify(data, null, 2);
            resultDiv.classList.remove("hidden");

            let predictionData = data.predictions;
            const file = formData.get("file");
            const imageUrl = URL.createObjectURL(file);

            displayImageWithBoundingBoxes(imageUrl, predictionData);
            generateQualityLegend(predictionData); // Update legend dynamically
          } catch (error) {
            console.error("Error uploading snapshot:", error);
            alert("Snapshot upload failed.");
          }
        }, "image/jpeg");
      });

      uploadForm.addEventListener("submit", async (e) => {
        e.preventDefault();
        const formData = new FormData(uploadForm);
        let imageWrapper = document.getElementById("imageWrapper");

        try {
          const response = await fetch("/upload-single-image", {
            method: "POST",
            body: formData,
          });
    </script>
</div>
<script>
    const uploadForm = document.getElementById('uploadForm');
    const batchForm = document.getElementById('batchForm');
    const resultDiv = document.getElementById('resultDiv');
    const resultData = document.getElementById('resultData');
    const videoResultData = document.getElementById('videoResultData');
    const captureSection = document.getElementById('captureSection');
    const videoSection = document.getElementById('videoSection');
    const webcam = document.getElementById('webcam');
    const videoStream = document.getElementById('videoStream');
    const snapshot = document.getElementById('snapshot');
    const capture = document.getElementById('capture');
    const startWebcam = document.getElementById('startWebcam');
    const startVideo = document.getElementById('startVideo');
    const uploadTab = document.getElementById('uploadTab');
    const captureTab = document.getElementById('captureTab');
    const batchTab = document.getElementById('batchTab');
    const videoTab = document.getElementById('videoTab');
    const uploadProgress = document.getElementById('uploadProgress');
    const uploadProgressValue = document.getElementById('uploadProgressValue');
    const uploadProgressPercentage = document.getElementById('uploadProgressPercentage');
    const batchProgress = document.getElementById('batchProgress');
    const batchProgressValue = document.getElementById('batchProgressValue');
    const batchProgressPercentage = document.getElementById('batchProgressPercentage');
    const batchResultDiv = document.getElementById('batchResultDiv');
    const batchResultData = document.getElementById('batchResultData');
    let streaming = false;
    const allTabs = [uploadTab, captureTab, batchTab, videoTab];
    const sections = [uploadForm, captureSection, batchForm, videoSection];
    allTabs.forEach((tab, index) => {
        tab.addEventListener('click', () => {
            stopAllVideoStreams();
            sections.forEach((section, i) => {
                if (index === i) {
                    section.classList.remove('hidden');
                    allTabs[i].classList.add('active');
                } else {
                    section.classList.add('hidden');
                    allTabs[i].classList.remove('active');
                }
            });
            resultDiv.classList.add('hidden');
            if (uploadResultDiv) uploadResultDiv.classList.add('hidden');
            if (uploadResultData) uploadResultData.textContent = '';
            if (batchResultDiv) batchResultDiv.classList.add('hidden');
            if (batchResultData) batchResultData.textContent = '';
        });
    });
    startWebcam.addEventListener('click', async () => {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ video: true });
            webcam.srcObject = stream;
            webcam.classList.remove('hidden');
            capture.classList.remove('hidden');
        } catch (error) {
            console.error('Webcam access error:', error);
            alert('Failed to access the camera. Please allow permissions and try again.');
        }
    });
    capture.addEventListener('click', () => {
        const context = snapshot.getContext('2d');
        snapshot.width = webcam.videoWidth;
        snapshot.height = webcam.videoHeight;
        context.drawImage(webcam, 0, 0, snapshot.width, snapshot.height);
        snapshot.toBlob(async (blob) => {
            const formData = new FormData();
            formData.append('file', blob, 'snapshot.jpg');
            try {
                const response = await fetch('/upload-single-image', {
                    method: 'POST',
                    body: formData
                });
                if (!response.ok) {
                    throw new Error('Upload failed.');
                }
                const data = await response.json();
                resultData.textContent = JSON.stringify(data, null, 2);
                resultDiv.classList.remove('hidden');
            } catch (error) {
                console.error('Error uploading snapshot:', error);
                alert('Snapshot upload failed.');
            }
        }, 'image/jpeg');
    });
    function updateProgress(percentage, isBatch = false) {
        const progressBar = isBatch ? batchProgressValue : uploadProgressValue;
        const progressText = isBatch ? batchProgressPercentage : uploadProgressPercentage;
        progressBar.style.width = `${percentage}%`;
        progressText.textContent = `${Math.round(percentage)}%`;
    }
    function simulateProgress(onProgress) {
        let progress = 0;
        const interval = setInterval(() => {
            if (progress < 90) {
                progress += Math.random() * 10;
                progress = Math.min(progress, 90);
                if (onProgress) onProgress(progress);
            }
        }, 300);

        return {
            complete: (callback) => {
                clearInterval(interval);
                if (onProgress) onProgress(100);
                if (callback) callback();
            },
            reset: () => {
                clearInterval(interval);
                if (onProgress) onProgress(0);
            }
        };
    }
    uploadForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        const formData = new FormData(uploadForm);
        
        // Reset and show progress bar
        uploadResultDiv.classList.add('hidden');
        uploadProgress.classList.remove('hidden');
        updateProgress(0);

        const progressSimulation = simulateProgress((progress) => {
            updateProgress(progress);
        });

        try {
            const response = await fetch('/upload-single-image', {
                method: 'POST',
                body: formData
            });

            if (!response.ok) {
                throw new Error('Upload failed');
            }

            const predictionData = await response.json();
            
            // Complete the progress animation and show results
            progressSimulation.complete(() => {
                uploadResultData.textContent = JSON.stringify(predictionData, null, 2);
                uploadResultDiv.classList.remove('hidden');

                // Hide progress bar after a delay
                setTimeout(() => {
                    uploadProgress.classList.add('hidden');
                }, 1000);
            });

        } catch (error) {
            console.error('Upload failed:', error);
            progressSimulation.reset();
            uploadProgress.classList.add('hidden');
            alert('Upload failed: ' + error.message);
        }
    });
    batchForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        const formData = new FormData(batchForm);
        
        batchResultDiv.classList.add('hidden');
        batchProgress.classList.remove('hidden');
        updateProgress(0, true);

        const progressSimulation = simulateProgress((progress) => {
            updateProgress(progress, true);
        });

        try {
          const response = await fetch("/upload-batch-images", {
            method: "POST",
            body: formData,
          });

          if (!response.ok) {
            throw new Error("Failed to upload batch.");
          }

            const predictionData = await response.json();
            
            // Complete the progress animation and show results
            progressSimulation.complete(() => {
                // Format the prediction data for better readability
                batchResultData.textContent = JSON.stringify(predictionData, null, 2);
                batchResultDiv.classList.remove('hidden');

                // Hide progress bar after a delay
                setTimeout(() => {
                    batchProgress.classList.add('hidden');
                    updateProgress(0, true);
                }, 1000);
            });

        } catch (error) {
            console.error('Batch upload failed:', error);
            progressSimulation.reset();
            batchProgress.classList.add('hidden');
            alert('Batch upload failed: ' + error.message);
        }
    });
    startVideo.addEventListener('click', async () => {
        if (!streaming) {
            const stream = await navigator.mediaDevices.getUserMedia({ video: true });
            videoStream.srcObject = stream;
            streaming = true;
            analyzeFrame();
        }
    });
    async function analyzeFrame() {
        if (!streaming) return;
        const videoCanvas = document.createElement('canvas');
        videoCanvas.width = 640;
        videoCanvas.height = (640 / videoStream.videoWidth) * videoStream.videoHeight;
        const videoContext = videoCanvas.getContext('2d');
        videoContext.drawImage(videoStream, 0, 0, videoCanvas.width, videoCanvas.height);
        videoCanvas.toBlob(async (blob) => {
            const formData = new FormData();
            formData.append('file', blob, 'frame.jpg');
            try {
                const response = await fetch('/upload-single-image', {
                    method: 'POST',
                    body: formData
                });
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                const data = await response.json();
                videoResultData.textContent = JSON.stringify(data, null, 2);
            } catch (error) {
                console.error('Error:', error);
            }
        }, 'image/jpeg');
        setTimeout(analyzeFrame, 500);
    }
    function stopAllVideoStreams() {
        if (videoStream.srcObject) {
            const tracks = videoStream.srcObject.getTracks();
            tracks.forEach(track => track.stop());
            videoStream.srcObject = null;
            streaming = false;
        }
        
        if (webcam.srcObject) {
            const tracks = webcam.srcObject.getTracks();
            tracks.forEach(track => track.stop());
            webcam.srcObject = null;
            webcam.classList.add('hidden');
            capture.classList.add('hidden');
        }
    }
</script>

    <script>

      document.addEventListener("DOMContentLoaded", () => {
        window.jsPDF = window.jspdf.jsPDF;

        const optionsData = {
          brightness: [
            { value: 0, label: "Bright, shining" },
            { value: 1, label: "Bright" },
            { value: 2, label: "Dull" },
          ],
          bloodspot: [
            { value: 0, label: "None" },
            { value: 1, label: "Small, 10-30%" },
            { value: 2, label: "Big, 30-50%" },
            { value: 3, label: "Very Big, 50-100%" },
          ],
          stiffness: [
            { value: 0, label: "Stiff" },
            { value: 1, label: "Elastic" },
            { value: 2, label: "Firm" },
            { value: 3, label: "Soft" },
          ],
          belly: [
            { value: 0, label: "Firm" },
            { value: 1, label: "Soft" },
            { value: 2, label: "Belly Burst" },
          ],
          smellofthefish: [
            { value: 0, label: "Fresh" },
            { value: 1, label: "Neutral" },
            { value: 2, label: "Musty" },
            { value: 3, label: "Stale meat/rancid" },
          ],
          clarity: [
            { value: 0, label: "Clear" },
            { value: 1, label: "Cloudy" },
          ],
          shape: [
            { value: 0, label: "Normal" },
            { value: 1, label: "Sunken" },
          ],
          colour: [
            { value: 0, label: "Bright red" },
            { value: 1, label: "Dark red" },
            { value: 2, label: "Pale" },
          ],
          smell: [
            { value: 0, label: "Fresh" },
            { value: 1, label: "Neutral" },
            { value: 2, label: "Sweaty" },
          ],
        };

        const dropdowns = document.querySelectorAll(".dropdown");
        const popup = document.getElementById("popup");
        const overlay = document.getElementById("overlay");
        const popupTitle = document.getElementById("popupTitle");
        const popupOptions = document.getElementById("popupOptions");
        const closePopup = document.getElementById("closePopup");
        const submitButton = document.querySelector("button[type='submit']");
        let activeDropdown;
        const userSelections = {}; // To store question, label, and value (score)

        dropdowns.forEach((dropdown) => {
          dropdown.addEventListener("change", function () {
            const selectedValue = this.value;
            const options = optionsData[selectedValue];
            activeDropdown = this;

            popupTitle.textContent = "Select an Option";
            popupOptions.innerHTML = "";

            options.forEach((option) => {
              const label = document.createElement("label");
              label.classList.add("flex", "items-center", "mb-2");

              const radio = document.createElement("input");
              radio.type = "radio";
              radio.name = "popupOption";
              radio.value = JSON.stringify(option); // Store both label and value
              radio.classList.add("mr-2");

              label.appendChild(radio);
              label.appendChild(document.createTextNode(option.label));

              popupOptions.appendChild(label);
            });

            popup.style.display = "block";
            overlay.style.display = "block";
          });
        });

        closePopup.addEventListener("click", function () {
          const selectedOption = document.querySelector('input[name="popupOption"]:checked');

          if (selectedOption) {
            const selectedData = JSON.parse(selectedOption.value);
            const { label, value } = selectedData;

            const currentOption = activeDropdown.querySelector(`option[value="${activeDropdown.value}"]`);
            currentOption.innerHTML = `${currentOption.textContent.split(" - ")[0]} - <span class="answer-text">Rate Answer: ${label} âœ“</span>`;

            userSelections[activeDropdown.value] = {
              question: currentOption.textContent.split(" - ")[0],
              label,
              score: value,
            };

            const allOptions = [...activeDropdown.options];
            const answeredOptions = allOptions.filter((opt) => opt.innerHTML.includes("Rate Answer:"));

            if (answeredOptions.length === allOptions.length - 1) {
              activeDropdown.querySelector("option").textContent = `${
                activeDropdown.querySelector("option").textContent.split(" (")[0]
              } (Completed Answering)`;
            }

            activeDropdown.value = "";
          }

          popup.style.display = "none";
          overlay.style.display = "none";
        });

        submitButton.addEventListener("click", (e) => {
          e.preventDefault();

          const uncompletedDropdowns = [...dropdowns].filter(
            (dropdown) => !dropdown.querySelector("option:first-child").textContent.includes("Completed Answering")
          );

          if (uncompletedDropdowns.length > 0) {
            alert("Please complete all the sections before submitting!");
          } else {
            const totalScore = Object.values(userSelections).reduce((acc, curr) => acc + curr.score, 0);
            const qualityLabel = getQualityLabel(totalScore);

            // Display the result dynamically
            const resultDisplay = document.getElementById("resultDisplay");
            const qualityResult = document.getElementById("qualityResult");

            qualityResult.textContent = qualityLabel;
            resultDisplay.classList.remove("hidden"); // Show result below submit button

            generatePDF(totalScore, qualityLabel);
            generateExcel(totalScore, qualityLabel);

            document.getElementById("downloadLinks").classList.remove("hidden");
          }
        });

        function getQualityLabel(score) {
          if (score <= 3) return "Prime Quality";
          if (score <= 5) return "High Quality";
          if (score <= 8) return "Good Quality";
          if (score <= 11) return "Acceptable";
          if (score <= 15) return "Marginal";
          if (score <= 19) return "Poor Quality";
          return "Unacceptable";
        }

        function getDetailedFormData() {
          const formData = {
            "General Appearance": [],
            Eyes: [],
            Gills: [],
          };

          Object.entries(userSelections).forEach(([field, { question, label, score }]) => {
            const section = getSectionName(field);
            formData[section].push({ question, label, score });
          });

          return formData;
        }

        function getSectionName(field) {
          if (["brightness", "bloodspot", "stiffness", "belly", "smellofthefish"].includes(field)) {
            return "General Appearance";
          } else if (["clarity", "shape"].includes(field)) {
            return "Eyes";
          } else if (["colour", "smell"].includes(field)) {
            return "Gills";
          }
          return "Other";
        }

        function generatePDF(totalScore, qualityLabel) {
          const formData = getDetailedFormData();
          const doc = new jsPDF();
          doc.setFontSize(16);
          doc.text("FISH ASSESSMENT FORM -  SUBMISSION SUMMARY", 10, 10);
          doc.setFontSize(12);
          let y = 20;

          Object.entries(formData).forEach(([section, questions]) => {
            doc.setFont("helvetica", "bold");
            doc.text(section.toUpperCase(), 10, y);
            y += 10;
            questions.forEach((question, index) => {
              doc.setFont("helvetica", "normal");
              doc.text(`${index + 1}. ${question.question}: ${question.label} (Score: ${question.score})`, 10, y);
              y += 10;
            });
            y += 5;
          });

          // Add bold Total Score and Quality
          doc.setFont("helvetica", "bold");
          doc.text(`Total Score: ${totalScore}`, 10, y);
          y += 10;
          doc.text(`Quality: ${qualityLabel}`, 10, y);

          const pdfBlob = doc.output("blob");
          const pdfURL = URL.createObjectURL(pdfBlob);
          document.getElementById("downloadPDF").href = pdfURL;
        }

        function generateExcel(totalScore, qualityLabel) {
          const formData = getDetailedFormData();
          const workbook = XLSX.utils.book_new();
          const worksheetData = [["Field", "Question", "Answer", "Score"]];

          // Add survey data to worksheet
          Object.entries(formData).forEach(([section, questions]) => {
            questions.forEach((question) => {
              worksheetData.push([section, question.question, question.label, question.score]);
            });
          });

          // Add Total Score and Quality rows
          worksheetData.push(["", "Total Score", totalScore, ""]);
          worksheetData.push(["", "Quality", qualityLabel, ""]);

          const worksheet = XLSX.utils.aoa_to_sheet(worksheetData);

          // Apply center alignment and bold styling for Total Score and Quality
          const range = XLSX.utils.decode_range(worksheet["!ref"]);

          for (let R = range.s.r; R <= range.e.r; ++R) {
            for (let C = range.s.c; C <= range.e.c; ++C) {
              const cellAddress = XLSX.utils.encode_cell({ r: R, c: C });
              if (!worksheet[cellAddress]) continue;

              // Apply center alignment for all cells
              if (!worksheet[cellAddress].s) worksheet[cellAddress].s = {};
              worksheet[cellAddress].s.alignment = { horizontal: "center", vertical: "center" };

              // Apply bold for Total Score and Quality rows
              if (R >= worksheetData.length - 2) {
                // Bold last two rows
                worksheet[cellAddress].s.font = { bold: true };
              }
            }
          }

          // Add worksheet to the workbook
          XLSX.utils.book_append_sheet(workbook, worksheet, "Fish Assessment Form");

          // Generate Excel file and download link
          const wbArrayBuffer = XLSX.write(workbook, { bookType: "xlsx", type: "array", cellStyles: true });
          const excelBlob = new Blob([wbArrayBuffer], { type: "application/octet-stream" });

          const excelURL = URL.createObjectURL(excelBlob);
          document.getElementById("downloadExcel").href = excelURL;
          document.getElementById("downloadExcel").download = "FishAssessment_Form_Submission.xlsx";
        }

        // Function to display the result
        function showResult(totalScore, qualityLabel) {
          const resultDiv = document.getElementById("resultDisplay");
          const emoji = getEmojiForQuality(qualityLabel);
          const color = getColorForQuality(qualityLabel);

          resultDiv.innerHTML = `
    <p style="font-size: 1.5rem; font-weight: bold;">
      Result (Quality): ${qualityLabel} ${emoji}
    </p>
  `;

          // Apply interactive styles
          resultDiv.style.backgroundColor = color;
          resultDiv.style.padding = "10px";
          resultDiv.style.borderRadius = "10px";
          resultDiv.style.textAlign = "center";
          resultDiv.style.color = "#fff";
          resultDiv.style.transition = "all 0.5s ease";
          resultDiv.classList.remove("hidden"); // Make it visible
        }

        // Map quality levels to emojis
        function getEmojiForQuality(quality) {
          switch (quality) {
            case "Prime Quality":
            case "High Quality":
              return "ðŸ˜Š"; // Happy mood
            case "Good Quality":
            case "Acceptable":
              return "ðŸ˜"; // Neutral mood
            case "Marginal":
            case "Poor Quality":
              return "ðŸ˜ž"; // Sad mood
            case "Unacceptable":
              return "ðŸ˜¡"; // Angry mood
            default:
              return "â“"; // Default
          }
        }

        // Map quality levels to background colors
        function getColorForQuality(quality) {
          switch (quality) {
            case "Prime Quality":
            case "High Quality":
              return "green"; // Happy
            case "Good Quality":
            case "Acceptable":
              return "orange"; // Neutral
            case "Marginal":
            case "Poor Quality":
              return "red"; // Sad
            case "Unacceptable":
              return "darkred"; // Angry
            default:
              return "gray"; // Default
          }
        }

        // Update submitButton to display result dynamically
        submitButton.addEventListener("click", (e) => {
          e.preventDefault();

          const totalScore = Object.values(userSelections).reduce((acc, curr) => acc + curr.score, 0);
          const qualityLabel = getQualityLabel(totalScore);

          showResult(totalScore, qualityLabel); // Call the result display function
          generatePDF(totalScore, qualityLabel);
          generateExcel(totalScore, qualityLabel);

          document.getElementById("downloadLinks").classList.remove("hidden");
        });
      });
    </script>
  </body>
</html>
